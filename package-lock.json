#include<stdio.h>
#include<malloc.h>
#include<math.h>
#include<stdlib.h>
struct poly
{
		int cf,px,py,pz;
		int flag;
            	struct poly *next;
};
typedef struct poly node;
node* getnode()
{
		node *nn;
		nn=(node*)malloc(sizeof(node));
		if(nn==NULL)
		{
			printf("Insufficient memory\n");
			exit(0);
		}
		return nn;
}
void display(node *head)
{
		node *p;
		if(head->next==head)
		{
			printf("Polynomial does not exist\n");
			return;
		}
		p=head->next;
		while(p!=head)
		{
			printf("%dx^%dy^%dz^%d",p->cf,p->px,p->py,p->pz);
			if(p->next!= head)
			printf(" + ");
			p=p->next;
		}
}
node* insert_rear(int cf,int x,int y,int z,node *head)
{
		node *p,*v;
		p=getnode();
		p->cf=cf;
		p->px=x;
		p->py=y;
		p->pz=z;
       		v=head->next;
		while(v->next!=head)
		{
			v=v->next;
		}
		v->next=p;
		p->next=head;
		return head;
}
node* read_poly(node *head)
{
		int px, py, pz, cf, ch;
		do
{
        		printf("Enter coeff: ");
			scanf("%d",&cf);
			printf("Enter powers of x,y,z\n ");
			scanf("%d%d%d",&px,&py,&pz);
			head=insert_rear(cf,px,py,pz,head);
			printf("If your wish to continue press 1 otherwise 0\n");
			scanf("%d", &ch);
	 	}while(ch != 0);
		return head;
}
node* add_poly(node *h1,node *h2,node *h3)
{
		node *p1,*p2;
		int x1,x2,y1,y2,z1,z2,cf1,cf2,cf;
		p1=h1->next;
		while(p1!=h1)
		{
			x1=p1->px;
			y1=p1->py;
			z1=p1->pz;
			cf1=p1->cf;
			p2=h2->next;
			while(p2!=h2)
			{
				x2=p2->px;
				y2=p2->py;
				z2=p2->pz;
				cf2=p2->cf;
				if(x1==x2 && y1==y2 && z1==z2)break;
				p2=p2->next;
			}
			if(p2!=h2)
			{
				cf=cf1+cf2;
				p2->flag=1;
				if(cf!=0)
				h3=insert_rear(cf,x1,y1,z1,h3);
			}
			else
				h3=insert_rear(cf1,x1,y1,z1,h3);
				p1=p1->next;
		}
		p2=h2->next;
		while(p2!=h2)
		{
			if(p2->flag==0)
			h3=insert_rear(p2->cf,p2->px,p2->py,p2->pz,h3);
			p2=p2->next;
		}
        	return h3;
}
void evaluate(node *head)
{
		node *p;
		int x, y, z;
		int result=0;
		p=head->next;
		printf("\nEnter x,y,z terms to evaluate:\n");
            	scanf("%d%d%d",&x,&y,&z);
            	while(p!= head)
           	{
        	 	result = result + (p->cf * pow(x,p->px) * pow(y,p->py) * pow(z,p->pz));
         		p=p->next;
        	}
		printf("Polynomial result is: %d", result);
}
void main()
{
		node *h1,*h2,*h3;
		int ch;
		h1=getnode();
		h2=getnode();
		h3=getnode();
            	h1->next=h1;
		h2->next=h2;
		h3->next=h3;
		while(1)
		{
			printf("\n\n1.Evaluate polynomial\n2.Add two polynomials\n3.Exit\n");
			printf("Enter your choice: ");
			scanf("%d", &ch);
			switch(ch)
			{
				case 1: h1->next=h1;
				printf("\nEnter polynomial to evaluate:\n");
				h1=read_poly(h1);
				printf("The polynomial is :");
				display(h1);
	         		evaluate(h1);
                             break;
                             case 2: h1->next=h1;
	        		printf("\nEnter the first polynomial:\n");
				h1=read_poly(h1);
				printf("\nEnter the second polynomial:\n");
				h2=read_poly(h2);
				h3=add_poly(h1,h2,h3);
				printf("\nFirst polynomial is: ");
				display(h1);
				printf("\nSecond polynomial is: ");
				display(h2);
				printf("\nThe sum of 2 polynomials is: \n");
				display(h3);
                             case 3: exit(0);
		              default:printf("\nInvalid entry");
				break;
			}		
          	}   
}


graph


#include<stdio.h>
#include<stdlib.h>
int st[10],top=-1,v[10],a[10][10],u[10];
int n,q[10],front=0;
int rear=-1;
void dfs(int s)
{
int i;
v[s]=1;
st[++top]=s;
for(i=1;i<=n;i++)
{
if(a[s][i]==1&&v[i]==0)
{
printf("Officer %d->Officer %d\n",s,i);
dfs(i);
}
}
}

void bfs(int s)
{
int m,i;
u[s]=1;
q[++rear]=s;
printf("Reachable officers using BFS method from a given officer : %d are\n",s);
while(front<=rear)
{
m=q[front++];
for(i=1;i<=n;i++)
{
if(a[m][i]==1&&u[i]==0)
{
q[++rear]=i;
printf("Officer %d\n",i);
u[i]=1;
}
}
}
}

void main() 
{
int s,i,j,ch;
while(1)
{
printf("1.Create a graph using adjacency matrix indicating people who can communicate directly with each other\n2.DFS traversal method through which any officer can be reachable from a given node\n3.BFS traversal method through which any officer can be reachable from a given node\n4.Exit\n");
printf("Enter the choice\n");
scanf("%d",&ch);
switch(ch)
{
case 1: printf("Enter the number of officers\n");
scanf("%d",&n);
printf("Enter the adjacency matrix representation\n");
for(i=1;i<=n;i++)
{
for(j=1;j<=n;j++)
{
scanf("%d",&a[i][j]);
}
}
break;
case 2:printf("Depth First Search Traversal\n");
                       		printf("Enter Source Officer\n");
scanf("%d",&s);
printf("Reachable officers using DFS method from a given officer:                %d\n",s);
dfs(s);
for(i=1;i<=n;i++)
{
if(v[i]==0)
{
	printf("%d is not visited and it is disconnected graph\n",i);
}
}
break;
case 3: printf("Breadth First Search Traversal\n");
printf("Enter Source Officer\n");
scanf("%d",&s);
bfs(s);
for(i=1;i<=n;i++)
{
if(u[i]==0)
{
printf("Officer %d is not visited and that officer is disconnected\n",i);
}
}
break;
case 4:exit(0);
default: printf("Invalid choice\n");
}
 }
  }
